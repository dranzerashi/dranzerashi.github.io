<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Ashith Raghunath — Pixels & Code</title>
  <meta name="description" content="Ashith Raghunath — Senior Technologist. Java, Spring Boot" />
   <link href="dist/output.css" rel="stylesheet">
  <style>
    canvas {
      position: fixed;  /* stay in the background */
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: -1; /* behind everything */
    }
    /* tiny pixel-ish border */
    .pixel-border { box-shadow: inset 0 0 0 2px rgba(255,255,255,0.03); }
    .neon-text { text-shadow: 0 2px 10px rgba(238,64,54,0.12), 0 0 18px rgba(0,255,179,0.06); }
  </style>
</head>
<body>
  <canvas id="c"></canvas>

<script>
/*
  Neo-cyberpunk cell infection simulation
  - Canvas only in body
  - Clusters limited to maxClusterSize
  - Healthy = pulsating blue; Infected = sickly green with 3 levels
  - Antibodies = golden, few (<=5), never infected, cure nearby connected cells
  - Edges drawn between nearby nodes (connections)
  - Live counts (numbers only) drawn top-right in matching colors
*/

const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d', {alpha: false});
let W = canvas.width = innerWidth;
let H = canvas.height = innerHeight;
addEventListener('resize', ()=>{ W=canvas.width=innerWidth; H=canvas.height=innerHeight; });

/* CONFIG */
const TOTAL_NODES = Math.max(60, Math.floor((W*H)/90000)); // scale with area
const MAX_CLUSTER_SIZE = 7;
const ANTIBODY_COUNT = Math.min(5, Math.max(1, Math.floor(TOTAL_NODES/40)));
const NODE_RADIUS = 2;
const MOVE_SPEED = 0.001; // slow
const INTENSITY_SCALE = 0.5;
const CELL_ATTRACTION = 0.000001; // attraction to cluster center
const EDGE_MAX_DIST = 110; // only connect to close nodes
const ANTIBODY_CONNECT_DIST = 60;
const INFECTION_PROB_PER_SEC = 0.8; // when connected
const INFECTION_STEP_SEC = 3.0; // time to progress infection level
const PULSE_FREQ = 2.0; // pulses per second
const BG = "rgba(0, 0, 0, 0.5)"; //'#08070a';

/* Utility */
function rand(a=0,b=1){return a + Math.random()*(b-a)}
function dist(a,b){let dx=a.x-b.x, dy=a.y-b.y; return Math.sqrt(dx*dx+dy*dy)}

/* Create clusters so components don't exceed MAX_CLUSTER_SIZE */
let nodes = [];
let edges = [];

/* Create clusters by filling until TOTAL_NODES */
let remaining = TOTAL_NODES;
let clusterCenters = [];
while (remaining > 0) {
  let size = Math.min(remaining, Math.floor(rand(2, MAX_CLUSTER_SIZE+1)));
  // pick a cluster center avoiding edges
  let cx = rand(80, W-80);
  let cy = rand(80, H-80);
  clusterCenters.push({x:cx,y:cy,size:size});
  remaining -= size;
}

/* Create nodes inside each cluster */
let idCounter = 0;
for (let c of clusterCenters){
  for (let i=0;i<c.size;i++){
    let angle = rand(0,Math.PI*2);
    let r = rand(0, Math.min(40, 12*c.size)); // spread natural
    let x = c.x + Math.cos(angle)*r + rand(-6,6);
    let y = c.y + Math.sin(angle)*r + rand(-6,6);
    nodes.push({
      id: idCounter++,
      x, y,
      vx: rand(-MOVE_SPEED, MOVE_SPEED),
      vy: rand(-MOVE_SPEED, MOVE_SPEED),
      radius: NODE_RADIUS + rand(-2,2),
      isAntibody: false,
      infectedLevel: 0, // 0=healthy, 1..3 infected levels
      infectedTimer: 0,
      pulseOffset: rand(0, Math.PI*2),
      clusterCenter: {x:c.x, y:c.y}
    });
  }
}

/* Allow occasional small random inter-cluster nodes movement by velocities */
/* Build edges: connect to near neighbors but keep cluster internal */
function buildEdges(){
  edges = [];
  const kd = nodes;
  for (let i=0;i<kd.length;i++){
    for (let j=i+1;j<kd.length;j++){
      let a=kd[i], b=kd[j];
      let d = dist(a,b);
      if (d <= EDGE_MAX_DIST){
        // Prefer intra-cluster: ensure natural clusters by probability
        let sameCluster = Math.hypot(a.clusterCenter.x - b.clusterCenter.x, a.clusterCenter.y - b.clusterCenter.y) < 1e-6;
        let keepProb = sameCluster ? 0.7 : 0.08; // mostly within cluster edges
        if (Math.random() < keepProb){
          edges.push({a: a.id, b: b.id, length: d});
        }
      }
    }
  }
  // Ensure each cluster is mostly connected: try to connect nodes in same cluster if isolated
  // simple pass: for each node, ensure at least one edge if possible
  for (let n of nodes){
    let has=false;
    for (let e of edges) if (e.a===n.id || e.b===n.id){ has=true; break; }
    if (!has){
      // connect to nearest neighbor within range
      let nearest=null, nd=1e9;
      for (let m of nodes){
        if (m===n) continue;
        let d=dist(n,m);
        if (d<nd){
          nd=d; nearest=m;
        }
      }
      if (nearest && nd < EDGE_MAX_DIST*1.2) edges.push({a:n.id,b:nearest.id,length:nd});
    }
  }
}
buildEdges();

/* Choose antibodies - they are not part of nodes so they are separate moving entities */
let antibodies = [];
for (let i=0;i<ANTIBODY_COUNT;i++){
  // place near cluster centers so they naturally connect to close cells
  let center = clusterCenters[Math.floor(rand(0, clusterCenters.length))];
  antibodies.push({
    id: 'ab'+i,
    x: center.x + rand(-30,30),
    y: center.y + rand(-30,30),
    vx: rand(-0.6,0.6),
    vy: rand(-0.6,0.6),
    radius: NODE_RADIUS*1.2,
    pulseOffset: rand(0,Math.PI*2)
  });
}

/* Random initial infections: seed a few */
let initialInfections = Math.max(1, Math.floor(TOTAL_NODES * 0.03));
for (let k=0;k<initialInfections;k++){
  const idx = Math.floor(rand(0, nodes.length));
  nodes[idx].infectedLevel = 1;
  nodes[idx].infectedTimer = 0;
}

// Ensure at least one infected exists
if (nodes.every(n => n.infectedLevel === 0)) {
  const idx = Math.floor(rand(0, nodes.length));
  nodes[idx].infectedLevel = 1;
  nodes[idx].infectedTimer = 0;
}

/* Simulation stepping */
let last = performance.now();

function step(dt){
  // Move nodes slowly, with gentle attraction to cluster center to avoid drifting apart
  for (let n of nodes){
    // tiny attraction to cluster center to keep clusters natural
    let ax = (n.clusterCenter.x - n.x) * CELL_ATTRACTION;
    let ay = (n.clusterCenter.y - n.y) * CELL_ATTRACTION;
    n.vx += ax * dt;
    n.vy += ay * dt;
    // friction
    n.vx *= 0.995;
    n.vy *= 0.995;
    n.x += n.vx * dt;
    n.y += n.vy * dt;
    // keep inside
    if (n.x < 20){ n.x = 20; n.vx = Math.abs(n.vx); }
    if (n.x > W-20){ n.x = W-20; n.vx = -Math.abs(n.vx); }
    if (n.y < 20){ n.y = 20; n.vy = Math.abs(n.vy); }
    if (n.y > H-20){ n.y = H-20; n.vy = -Math.abs(n.vy); }
    // small random jitter
    n.vx += rand(-0.0008,0.0008) * dt;
    n.vy += rand(-0.0008,0.0008) * dt;

    // Infection progress timer
    if (n.infectedLevel > 0){
      n.infectedTimer += dt/1000;
      if (n.infectedTimer >= INFECTION_STEP_SEC){
        n.infectedTimer = 0;
        if (n.infectedLevel < 3){
          n.infectedLevel++;
        } else {
          // stay at level 3 (chronic)
        }
      }
    }
  }

  // Antibodies move, gentle wandering and bounce
  for (let a of antibodies){
    a.vx += rand(-0.002,0.002) * dt;
    a.vy += rand(-0.002,0.002) * dt;
    a.vx *= 0.995;
    a.vy *= 0.995;
    a.x += a.vx * dt;
    a.y += a.vy * dt;
    if (a.x < 20){ a.x = 20; a.vx = Math.abs(a.vx); }
    if (a.x > W-20){ a.x = W-20; a.vx = -Math.abs(a.vx); }
    if (a.y < 20){ a.y = 20; a.vy = Math.abs(a.vy); }
    if (a.y > H-20){ a.y = H-20; a.vy = -Math.abs(a.vy); }
  }

  // Infection spread across edges: for each edge with one infected node, attempt to infect neighbor
  for (let e of edges){
    let A = nodes[e.a], B = nodes[e.b];
    // If antibody is near either, it cures them (immediate) - antibodies only connect to very close cells
    // We'll check antibodies separately below

    // Infection propagation A -> B
    if (A.infectedLevel > 0 && B.infectedLevel === 0){
      // probability scaled by distance and dt
      let d = dist(A,B);
      let closeFactor = 1 - Math.min(1, d / EDGE_MAX_DIST);
      let prob = INFECTION_PROB_PER_SEC * closeFactor * (dt/1000);
      if (Math.random() < prob) {
        B.infectedLevel = 1;
        B.infectedTimer = 0;
      }
    }
    // B -> A
    if (B.infectedLevel > 0 && A.infectedLevel === 0){
      let d = dist(A,B);
      let closeFactor = 1 - Math.min(1, d / EDGE_MAX_DIST);
      let prob = INFECTION_PROB_PER_SEC * closeFactor * (dt/1000);
      if (Math.random() < prob) {
        A.infectedLevel = 1;
        A.infectedTimer = 0;
      }
    }
  }

  // Antibodies cure connected nearby cells (they connect only to very close cells)
  for (let a of antibodies){
    for (let n of nodes){
      let d = Math.hypot(a.x-n.x, a.y-n.y);
      if (d <= ANTIBODY_CONNECT_DIST){
        // cure - set to healthy
        if (n.infectedLevel > 0){
          n.infectedLevel = 0;
          n.infectedTimer = 0;
        }
        // also provide slight repulsive push to show interaction
        let dx = n.x - a.x, dy = n.y - a.y;
        let nd = Math.sqrt(dx*dx + dy*dy) || 0.0001;
        n.vx += (dx/nd) * 0.12;
        n.vy += (dy/nd) * 0.12;
        let speed = Math.sqrt(n.vx*n.vx + n.vy*n.vy);
        let maxSpeed = 0.3;
        if (speed > maxSpeed) {
          n.vx = (n.vx / speed) * maxSpeed;
          n.vy = (n.vy / speed) * maxSpeed;
        }
      }
    }
  }
}

/* RENDERING - neo cyberpunk noir theme */
function drawGlowCircle(x,y,r, color, intensity=12){
  intensity = intensity * INTENSITY_SCALE;
  ctx.save();
  ctx.globalCompositeOperation = 'lighter';
  for (let i=0;i<intensity;i++){
    ctx.beginPath();
    ctx.fillStyle = color;
    ctx.globalAlpha = 0.03 + (0.02 * (intensity - i));
    ctx.arc(x, y, r + i*2, 0, Math.PI*2);
    ctx.fill();
  }
  ctx.restore();
}

function render(t){
  // t is timestamp
  //ctx.fillStyle = BG;
  //ctx.fillRect(0,0,W,H);
    const gradient = ctx.createLinearGradient(0, 0, 0, H);
    gradient.addColorStop(0, "#071021");   // top
    gradient.addColorStop(0.5, "#0b1220"); // middle
    gradient.addColorStop(1, "#07101a");   // bottom

    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, W, H);
  // subtle vignette / grain - neon noise lines (sparse)
  ctx.save();
  ctx.globalAlpha = 0.05;
  for (let i=0;i<6;i++){
    ctx.beginPath();
    ctx.moveTo(rand(0,W), rand(0,H));
    ctx.lineTo(rand(0,W), rand(0,H));
    ctx.strokeStyle = '#0f1722';
    ctx.lineWidth = 1;
    ctx.stroke();
  }
  ctx.restore();

  // Edges drawn first
  ctx.lineWidth = 1;
  for (let e of edges){
    let A = nodes[e.a], B = nodes[e.b];
    let d = dist(A,B);
    if (d > EDGE_MAX_DIST*1.05) continue;
    // edge color depends on infection presence
    let infectedCount = (A.infectedLevel>0?1:0) + (B.infectedLevel>0?1:0);
    let alpha = 0.08 + (1 - d/EDGE_MAX_DIST) * 0.28;
    if (infectedCount === 0){
      // healthy cyan-ish edges neon
      ctx.strokeStyle = `rgba(45,220,255,${alpha})`;
    } else {
      // sickly green
      ctx.strokeStyle = `rgba(152,235,113,${alpha+0.05})`;
    }
    // soft glow line by drawing thicker transparent line below
    ctx.beginPath();
    ctx.moveTo(A.x,A.y);
    ctx.lineTo(B.x,B.y);
    ctx.stroke();
  }

  // Antibody edges (connections) drawn
  for (let a of antibodies){
    for (let n of nodes){
      let d = Math.hypot(a.x-n.x, a.y-n.y);
      if (d <= ANTIBODY_CONNECT_DIST){
        ctx.beginPath();
        ctx.moveTo(a.x, a.y);
        ctx.lineTo(n.x, n.y);
        ctx.strokeStyle = `rgba(255,215,90,${0.25 + (1 - d/ANTIBODY_CONNECT_DIST)*0.45})`;
        ctx.lineWidth = 1.2;
        ctx.stroke();
      }
    }
  }

  // Nodes: draw glow + core with pulsation
  const nowSec = t/1000;
  for (let n of nodes){
    // pulse based on time
    let pulse = 0.08 * Math.sin((nowSec + n.pulseOffset) * PULSE_FREQ * Math.PI * 2) + 0.12;
    let r = n.radius * (1 + pulse);

    if (n.infectedLevel === 0){
      // healthy: pulsating blue neon
      let core = `rgba(60,170,255,1)`;
      let glow = `rgba(35,120,255,0.12)`;
      drawGlowCircle(n.x, n.y, r*2.4, glow, 10);
      // core circle with small inner glow
      ctx.beginPath();
      ctx.fillStyle = core;
      ctx.globalAlpha = 1;
      ctx.arc(n.x, n.y, r, 0, Math.PI*2);
      ctx.fill();

      // inner pulsating ring
      ctx.beginPath();
      ctx.strokeStyle = `rgba(180,220,255,${0.9*pulse+0.05})`;
      ctx.lineWidth = 1.5;
      ctx.arc(n.x,n.y,r+2+pulse*2,0,Math.PI*2);
      ctx.stroke();

    } else {
      // infected: sickly green, 3 levels -> change hue/opacity/shape
      let level = n.infectedLevel;
      // colors per level (duller neon for higher)
      let coreColors = [
        null,
        'rgba(170,240,120,1)',
        'rgba(150,220,110,1)',
        'rgba(120,200,80,1)'
      ];
      let glowColors = [
        null,
        'rgba(200,255,150,0.18)',
        'rgba(185,240,130,0.16)',
        'rgba(155,220,110,0.14)'
      ];
      drawGlowCircle(n.x, n.y, r*2.6, glowColors[level], 9 - level);
      // core - slight sickly wobble
      ctx.beginPath();
      ctx.fillStyle = coreColors[level];
      ctx.arc(n.x + Math.sin(nowSec*5 + n.id)*0.6*level, n.y + Math.cos(nowSec*4 + n.id)*0.6*level, r, 0, Math.PI*2);
      ctx.fill();

      // small jagged ring for higher infection
      if (level >=2){
        ctx.beginPath();
        ctx.strokeStyle = `rgba(100,190,60,${0.7 - level*0.12})`;
        ctx.lineWidth = 1.4;
        ctx.setLineDash([2,3]);
        ctx.arc(n.x, n.y, r+3 + level, 0, Math.PI*2);
        ctx.stroke();
        ctx.setLineDash([]);
      }
    }

    // faint cyberpunk outline
    ctx.beginPath();
    ctx.lineWidth = 0.8;
    ctx.strokeStyle = 'rgba(18,18,20,0.25)';
    ctx.arc(n.x,n.y,r,0,Math.PI*2);
    ctx.stroke();
  }

  // Antibodies: golden pulsating nodes with strong glow
  for (let a of antibodies){
    let pulse = 0.14 * Math.sin((nowSec + a.pulseOffset) * 3.6) + 0.18;
    let r = a.radius * (1 + pulse*0.7);
    drawGlowCircle(a.x, a.y, r*2.8, 'rgba(255,200,90,0.18)', 14);
    ctx.beginPath();
    ctx.fillStyle = 'rgba(255,210,110,1)';
    ctx.arc(a.x, a.y, r, 0, Math.PI*2);
    ctx.fill();
    // inner golden core
    ctx.beginPath();
    ctx.fillStyle = 'rgba(255,245,200,0.9)';
    ctx.arc(a.x, a.y, r*0.5, 0, Math.PI*2);
    ctx.fill();
  }

  // Top-right counts (numbers only, no words). Show healthy then infected as two digits stacked
  let healthyCount = nodes.filter(n=>n.infectedLevel===0).length;
  let infectedCount = nodes.filter(n=>n.infectedLevel>0).length;

  // draw a subtle panel (no text besides numbers)
  const pad = 12;
  const numSize = Math.max(18, Math.floor(Math.min(W,H) * 0.03));
  const boxWidth = Math.max(70, numSize*4);
  const boxHeight = numSize*2.8;
  const x = W - boxWidth - 20;
  const y = 20;

  // background rectangle with neon border
  ctx.save();
  //ctx.globalAlpha = 0.18;
  //ctx.fillStyle = '#060609';
  //ctx.fillRect(x-6, y-6, boxWidth+12, boxHeight+12);
  ctx.restore();

  // healthy number (blue) - top row
  ctx.font = `bold ${numSize}px system-ui, sans-serif`;
  ctx.textAlign = 'right';
  ctx.textBaseline = 'top';
  // shadow/neon
  ctx.save();
  ctx.shadowColor = 'rgba(30,140,255,0.8)';
  ctx.shadowBlur = 18;
  ctx.fillStyle = 'rgba(80,200,255,1)';
  ctx.fillText(String(healthyCount), x + boxWidth - pad, y + 4);
  ctx.restore();

  // infected number (sickly green) - below
  ctx.save();
  ctx.shadowColor = 'rgba(160,230,100,0.9)';
  ctx.shadowBlur = 18;
  ctx.fillStyle = 'rgba(170,240,120,1)';
  ctx.fillText(String(infectedCount), x + boxWidth - pad, y + numSize + 6);
  ctx.restore();

  // small signature glitch lines (cyberpunk flavor)
  ctx.globalAlpha = 0.06;
  ctx.strokeStyle = '#66ffee';
  ctx.beginPath();
  ctx.moveTo(20, H-30);
  ctx.lineTo(120, H-40);
  ctx.stroke();
}

/* Main loop */
function loop(now){
  const dt = Math.min(50, now - last); // cap dt for stability
  step(dt);
  render(now);
  last = now;
  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

/* Optional: allow clicking to create a small local infection burst */
canvas.addEventListener('click', (e)=>{
  const rect = canvas.getBoundingClientRect();
  const mx = e.clientX - rect.left, my = e.clientY - rect.top;
  // infect nearest node within 100px
  let nearest = null, nd = 1e9;
  for (let n of nodes){
    let d = Math.hypot(n.x-mx,n.y-my);
    if (d < nd){ nd=d; nearest=n; }
  }
  if (nearest && nd < 120){
    nearest.infectedLevel = 1;
    nearest.infectedTimer = 0;
  }
});

/* keyboard: press 'r' to rebuild edges (re-randomize connections) */
addEventListener('keydown', (ev)=>{
  if (ev.key === 'r' || ev.key === 'R'){
    buildEdges();
  }
});

</script>
<div class="bg-gradient-to-b from-[#071021]/80 via-[#0b1220]/70 to-[#07101a]/80 min-h-screen text-slate-100 antialiased">
  <main class="max-w-4xl mx-auto p-6 lg:p-12">
    <section class="relative grid grid-cols-1 lg:grid-cols-3 gap-8 items-center">
      <!-- Avatar / Pixel badge -->
      <div class="lg:col-span-1 flex items-center justify-center">
        <div class="w-40 h-40 rounded-2xl backdrop-blur-md bg-[linear-gradient(135deg,#0d1b2a_0%,#071021_100%)] border border-white/5 pixel-border shadow-neon-lg flex items-center justify-center">
          <div class="w-38 h-38 bg-[#0d1b2a] rounded-md flex flex-col items-center justify-center">
            <!-- simple pixel-ish P C icon -->
            <div class="text-center">
              <!-- on click of image redirect to pixels & code youtube -->
                <img src="/asset/pnc.png" alt="Pixels & Code Logo" class="w-38 h-38" onclick="window.location.href='https://www.youtube.com/@pixelsncode';" style="cursor: pointer;">
            </div>
          </div>
        </div>
      </div>

      <!-- Hero -->
      <div class="lg:col-span-2 bg-white/10 p-4 rounded-xl pixel-border">
        <h1 class="text-4xl sm:text-5xl font-extrabold tracking-tight neon-text mb-3">Ashith Raghunath</h1>
        <p class="text-lg text-slate-300 mb-4">Senior Technologist • Java & Spring Boot Microservices• Game Dev tinkerer • Building pixels & shaping code into experiences.</p>

        <div class="flex flex-wrap gap-3 mb-6">
          <span class="px-3 py-1 rounded-md bg-white/5 text-sm text-[#FFB000] font-medium">Java • Spring Boot</span>
          <span class="px-3 py-1 rounded-md bg-white/5 text-sm text-[#EE4036] font-medium">Microservices</span>
          <span class="px-3 py-1 rounded-md bg-white/5 text-sm text-[#9fbfff] font-medium">Cloud & Distributed Systems</span>
          <span class="px-3 py-1 rounded-md bg-white/5 text-sm text-[#00FFB3] font-medium">Game Dev</span>
        </div>

        <p class="text-slate-300 leading-relaxed">I design and build scalable backend systems and love turning ideas into playable things. With a decade in backend microservices, distributed data stores, and event-driven systems, I switch between architecting robust APIs by day and experimenting with game mechanics by night.</p>
      </div>
    </section>

    <!-- About / Stats -->
    <section class="mt-12 grid grid-cols-1 md:grid-cols-3 gap-6">
      <div class="bg-white/3 p-4 rounded-xl pixel-border">
        <h3 class="text-sm text-white/80 uppercase font-semibold mb-2">Experience</h3>
        <p class="text-slate-200">Senior Technologist at Infosys, 9+ years working on backend microservices, event-driven systems, and scalable APIs.</p>
      </div>
      <div class="bg-white/3 p-4 rounded-xl pixel-border">
        <h3 class="text-sm text-white/80 uppercase font-semibold mb-2">Stack</h3>
        <p class="text-slate-200">Java, Spring Boot, Kafka, Cassandra, PostgreSQL, Azure Cosmos DB, Docker, Kubernetes.</p>
      </div>
      <div class="bg-white/3 p-4 rounded-xl pixel-border">
        <h3 class="text-sm text-white/80 uppercase font-semibold mb-2">Interests</h3>
        <p class="text-slate-200">Game dev (roguelikes, pixel art), Android, AI experiments, developer tooling, open-source.</p>
      </div>
    </section>


    <!-- Contact / Socials -->
    <section id="contact" class="mt-12 grid grid-cols-1 md:grid-cols-2 gap-6 items-start">
      <div class="bg-white/4 p-6 rounded-xl pixel-border">
        <h3 class="text-lg font-semibold mb-2">Socials</h3>
        <div class="flex flex-row gap-2">
          <a href="https://github.com/dranzerashi" class="text-[#00FFB3] hover:underline">GitHub</a>
          <a href="https://www.linkedin.com/in/ashith-raghunath" class="text-[#9fbfff] hover:underline">LinkedIn</a>
          <a href="https://www.youtube.com/@pixelsncode" class="text-[#FFB000] hover:underline">YouTube</a>
        </div>
      </div>
    </section>

    <footer class="mt-12 text-center text-sm text-slate-500">© 2025 Ashith Raghunath — Pixels & Code</footer>
  </main>
  </div>
</body>
</html>
